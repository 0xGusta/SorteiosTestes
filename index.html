<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorteios 0xGus - Testnet Monad</title>
    <link rel="icon" href="/images/favicon.ico">
    <script src="https://cdn.jsdelivr.net/npm/web3@1.8.0/dist/web3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Ancizar+Sans:ital,wght@0,100..1000;1,100..1000&family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap');
        body { font-family: 'Ancizar Sans', sans-serif; }
        h1, h2, h3 { font-family: 'Montserrat', sans-serif; }
        .image-3d { transition: transform 0.1s ease-out; transform-style: preserve-3d; }
        .truncate-address { display: inline-block; width: 100px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1f2937; color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.5); z-index: 1000; text-align: center; }
        .popup-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 999; }
        #cookieConsent { padding: 20px; font-size: 1.1rem; }
        #cookieConsent p { margin-bottom: 10px; }
        #participantsSection { min-height: 200px; max-height: 300px; overflow-y: auto; background: #1f2937; border: 1px solid #374151; border-radius: 8px; padding: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        #participantsList { list-style: none; padding: 0; }
        #participantsList li { display: flex; align-items: center; padding: 12px; margin-bottom: 8px; background: linear-gradient(to right, #374151, #2d3748); border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.2); transition: transform 0.2s; }
        #participantsList li:hover { transform: translateY(-2px); }
        #participantsList li::before { content: attr(data-rank) "º"; display: inline-block; width: 30px; height: 30px; line-height: 30px; text-align: center; background: #15803d; color: white; border-radius: 50%; margin-right: 12px; font-weight: bold; }
        #participantsSection::-webkit-scrollbar { width: 8px; }
        #participantsSection::-webkit-scrollbar-track { background: #2d3748; border-radius: 4px; }
        #participantsSection::-webkit-scrollbar-thumb { background: #16a34a; border-radius: 4px; }
        #participantsSection::-webkit-scrollbar-thumb:hover { background: #15803d; }
        @media (max-width: 768px) {
            #participantsSection { padding: 12px; }
            #participantsList li { font-size: 0.9rem; padding: 10px; }
            #participantsList li::before { width: 24px; height: 24px; line-height: 24px; font-size: 0.8rem; }
        }
        #logo { border-radius: 20%; width: 128px; height: 128px; }
        #walletMenu { z-index: 1001; transition: opacity 0.3s ease, transform 0.3s ease; transform: translateY(-10px); opacity: 0; }
        #walletMenu:not(.hidden) { transform: translateY(0); opacity: 1; }
        @media (max-width: 768px) { #walletMenu { width: 100%; right: 0; } }
        .action-button { background-color: #16a34a; color: white; padding: 12px 24px; border-radius: 12px; transition: background-color 0.2s; }
        .action-button:hover:not(:disabled) { background-color: #15803d; }
        .secondary-button { background-color: #4b5563; color: white; padding: 12px 24px; border-radius: 12px; transition: background-color 0.2s; }
        .secondary-button:hover:not(:disabled) { background-color: #374151; }
        .disabled-button { background-color: #4b5563; color: white; padding: 12px 24px; border-radius: 12px; cursor: not-allowed; }
        .error-text { color: #f87171; }
        .loader { border: 4px solid #e5e7eb; border-top: 4px solid #16a34a; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen flex flex-col">
    <div id="popupOverlay" class="popup-overlay"></div>
    <div id="errorPopup" class="popup">
        <p id="errorMessage"></p>
        <button id="closeErrorPopup" class="mt-4 secondary-button">Fechar</button>
    </div>
    <div id="processingPopup" class="popup">
        <p>Transação em andamento...</p>
        <div class="loader"></div>
    </div>
    <div id="thanksPopup" class="popup">
        <p id="thanksMessage"></p>
        <button id="closeThanksPopup" class="mt-4 action-button">Fechar</button>
    </div>
    <div id="usernamePopup" class="popup">
        <p>Por favor, insira seu username do X:</p>
        <input id="twitterUsernameInput" type="text" placeholder="username ou @username" class="border border-gray-600 bg-gray-800 text-white p-2 w-full mb-2 rounded">
        <button id="submitUsername" class="mt-4 action-button">Enviar</button>
    </div>
    <div id="metamaskMobilePopup" class="popup">
        <p>Para conectar sua carteira no celular, use o <strong>navegador embutido do MetaMask</strong>.</p>
        <p>Abra o app MetaMask, vá para o navegador interno e acesse este site novamente.</p>
        <button id="closeMetamaskMobilePopup" class="mt-4 secondary-button">Entendido</button>
    </div>
    <div id="cookieConsent" class="popup">
        <p>Este site usa cookies para melhorar sua experiência.</p>
        <button id="acceptCookies" class="action-button">Aceitar</button>
    </div>
    <header class="bg-gray-800 w-full py-4 shadow-lg">
        <div class="container mx-auto px-4 flex justify-between items-center">
            <img id="logo" src="/images/iconmain.png" alt="Sorteios 0xGus" width="128" height="128">
            <div class="relative flex gap-2">
                <button id="walletButton" class="action-button">Conectar Carteira</button>
                <div id="walletMenu" class="hidden absolute right-0 mt-2 w-48 bg-gray-700 text-white rounded-lg shadow-lg">
                    <div class="p-2 border-b border-gray-600">
                        <p><strong>Endereço:</strong> <span id="userAddress" class="truncate-address"></span></p>
                    </div>
                    <div class="p-2 border-b border-gray-600">
                        <p><strong>X:</strong> <span id="xUsernameDisplay"></span></p>
                        <p class="text-sm text-gray-400">Errou o @? Reconecte a wallet e compre mais 1 ticket ou entre em contato com <a href="https://x.com/0xGustavo" target="_blank" class="underline hover:text-green-600">0xGus</a></p>
                    </div>
                    <button id="disconnectWallet" class="w-full text-left p-2 secondary-button">Desconectar Carteira</button>
                </div>
            </div>
        </div>
    </header>
    <div class="container mx-auto px-4 py-4 flex gap-4">
        <button id="drawWinnerButton" class="action-button hidden">Sortear Ganhador</button>
        <button id="refundParticipantsButton" class="action-button hidden">Reembolsar Participantes</button>
    </div>
    <main class="container mx-auto px-4 py-8 flex flex-col md:flex-row gap-8 flex-1">
        <div class="md:w-1/2">
            <h2 class="text-xl font-semibold mb-4 text-white">Monadverse Chapter 2 + 7 MON</h2>
            <div class="overflow-hidden rounded-lg">
                <img id="sorteioImage" src="/images/mv2.jpg" alt="Sorteio 0xGus" class="w-full h-auto image-3d">
            </div>
        </div>
        <div class="md:w-1/2">
            <h2 class="text-xl font-semibold mb-4 text-white">Comprar Tickets</h2>
            <p class="text-gray-400 mb-2">Data do sorteio: 30 de maio às 11h BRT</p>
            <div id="ticketSection" class="bg-gray-800 p-6 rounded-lg">
                <p><strong>Preço do Ticket:</strong> <span id="ticketPrice">0.2</span> MON</p>
                <p><strong>Carteiras Participantes:</strong> <span id="participantCount">0</span></p>
                <p><strong>Seus Tickets:</strong> <span id="ticketCount">Conecte sua Wallet</span></p>
                <div id="buyTicketsForm" class="mt-4">
                    <div class="flex items-center gap-4">
                        <div>
                            <label for="ticketQuantity" class="block text-sm font-medium">Quantidade de Tickets:</label>
                            <input id="ticketQuantity" type="number" min="1" step="1" value="1" class="border border-gray-600 bg-gray-800 text-white p-2 w-24 rounded">
                            <p id="ticketQuantityError" class="error-text text-sm mt-1 hidden">Por favor, insira um número inteiro maior ou igual a 1.</p>
                        </div>
                        <div>
                            <label class="block text-sm font-medium">Saldo:</label>
                            <p id="walletBalance" class="text-gray-400">0 MON</p>
                        </div>
                    </div>
                    <p><strong>Total:</strong> <span id="totalCost">0.2</span> MON</p>
                    <p id="raffleStatus" class="error-text mt-2 hidden">Sorteio Fechado</p>
                    <button id="buyTickets" class="disabled-button w-full mt-2" disabled>Conecte sua wallet primeiro</button>
                </div>
            </div>
        </div>
    </main>
    <section class="container mx-auto px-4 py-8">
        <div class="md:w-1/2 mx-auto">
            <div id="participantsSection">
                <h2 class="text-xl font-semibold mb-4 text-white">Ranking de Participantes (Top 5)</h2>
                <ul id="participantsList" class="bg-gray-800 p-4 rounded-lg list-none"></ul>
            </div>
        </div>
    </section>
    <footer class="bg-gray-800 text-white w-full py-4">
        <div class="container mx-auto px-4 text-center">
            <p>Desenvolvido por <a href="https://x.com/0xGustavo" target="_blank" class="underline hover:text-green-600">0xGus</a></p>
        </div>
    </footer>
    <script>
        const MONAD_TESTNET = {
            chainId: "0x279f",
            chainName: "Monad Testnet",
            rpcUrls: ["https://testnet-rpc.monad.xyz"],
            nativeCurrency: { name: "MON", symbol: "MON", decimals: 18 },
            blockExplorerUrls: ["https://testnet.monadexplorer.com"]
        };
        const CONTRACT_ADDRESS = "0x1Fa8151B96adEE65470404EC2F5628CC5ace4058";
        const CONTRACT_ABI = [
            {"inputs":[],"stateMutability":"nonpayable","type":"constructor"},
            {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"participant","type":"address"},{"indexed":false,"internalType":"string","name":"newAlias","type":"string"}],"name":"AliasUpdated","type":"event"},
            {"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"raffleNumber","type":"uint256"}],"name":"RaffleStarted","type":"event"},
            {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"participant","type":"address"},{"indexed":false,"internalType":"uint256","name":"quantity","type":"uint256"},{"indexed":false,"internalType":"string","name":"_alias","type":"string"}],"name":"TicketPurchased","type":"event"},
            {"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newPrice","type":"uint256"}],"name":"TicketPriceUpdated","type":"event"},
            {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"winner","type":"address"},{"indexed":false,"internalType":"uint256","name":"raffleNumber","type":"uint256"}],"name":"WinnerDrawn","type":"event"},
            {"inputs":[{"internalType":"string","name":"_alias","type":"string"}],"name":"buyTicket","outputs":[],"stateMutability":"payable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"_quantity","type":"uint256"},{"internalType":"string","name":"_alias","type":"string"}],"name":"buyTickets","outputs":[],"stateMutability":"payable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"_quantity","type":"uint256"},{"internalType":"string","name":"_newAlias","type":"string"}],"name":"buyTicketsWithNewAlias","outputs":[],"stateMutability":"payable","type":"function"},
            {"inputs":[],"name":"drawWinner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"address","name":"_participant","type":"address"}],"name":"getAlias","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"getContractBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"getParticipants","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"getPastWinners","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"_participant","type":"address"}],"name":"getTicketCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"isRaffleThreshold","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"raffleNumber","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"refundParticipants","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[],"name":"startRaffle","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"_newPrice","type":"uint256"}],"name":"setTicketPrice","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[],"name":"ticketPrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"string","name":"_newAlias","type":"string"}],"name":"updateAlias","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"stateMutability":"payable","type":"receive"}
        ];
        let web3, contract, userAddress, isWalletConnected = false, isConnecting = false, isProcessing = false;
        let xUsername = "";
        let acceptedCookies = false;
        let cache = { data: null, timestamp: 0, validDuration: 60000 };
        let currentTicketPrice = "200000000000000000"; // 0.2 MON em Wei

        const BUY_TICKETS_FORM = `
            <p><strong>Preço do Ticket:</strong> <span id="ticketPrice">0.2</span> MON</p>
            <p><strong>Carteiras Participantes:</strong> <span id="participantCount">0</span></p>
            <p><strong>Seus Tickets:</strong> <span id="ticketCount">Conecte sua Wallet</span></p>
            <div id="buyTicketsForm" class="mt-4">
                <div class="flex items-center gap-4">
                    <div>
                        <label for="ticketQuantity" class="block text-sm font-medium">Quantidade de Tickets:</label>
                        <input id="ticketQuantity" type="number" min="1" step="1" value="1" class="border border-gray-600 bg-gray-800 text-white p-2 w-24 rounded">
                        <p id="ticketQuantityError" class="error-text text-sm mt-1 hidden">Por favor, insira um número inteiro maior ou igual a 1.</p>
                    </div>
                    <div>
                        <label class="block text-sm font-medium">Saldo:</label>
                        <p id="walletBalance" class="text-gray-400">0 MON</p>
                    </div>
                </div>
                <p><strong>Total:</strong> <span id="totalCost">0.2</span> MON</p>
                <p id="raffleStatus" class="error-text mt-2 hidden">Sorteio Finalizado</p>
                <button id="buyTickets" class="disabled-button w-full mt-2" disabled>Conecte sua wallet primeiro</button>
            </div>
        `;

        async function init() {
            try {
                console.log("Inicializando Web3 com RPC público...");
                web3 = new Web3(new Web3.providers.HttpProvider(MONAD_TESTNET.rpcUrls[0]));
                contract = new web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);
                console.log("Contrato inicializado:", CONTRACT_ADDRESS);
            } catch (error) {
                console.error("Erro ao inicializar Web3:", error);
                showErrorPopup("Erro ao conectar ao contrato. Tente novamente mais tarde.");
                return;
            }
            if (Cookies.get("userAddress") && window.ethereum) {
                try {
                    console.log("Restaurando conexão via cookie...");
                    web3 = new Web3(window.ethereum);
                    contract = new web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);
                    const accounts = await window.ethereum.request({ method: "eth_accounts" });
                    if (accounts.length > 0) {
                        userAddress = accounts[0];
                        isWalletConnected = true;
                        xUsername = Cookies.get("xUsername") || "";
                        document.getElementById("walletButton").innerText = `Wallet: ${truncateAddress(userAddress)}`;
                        document.getElementById("userAddress").innerText = userAddress;
                        document.getElementById("xUsernameDisplay").innerText = xUsername || "N/A";
                    } else {
                        Cookies.remove("userAddress");
                        Cookies.remove("xUsername");
                    }
                } catch (error) {
                    console.error("Erro ao restaurar conexão:", error);
                    Cookies.remove("userAddress");
                    Cookies.remove("xUsername");
                }
            }
            document.getElementById("walletButton").addEventListener("click", debounce(connectWallet, 500));
            document.getElementById("disconnectWallet").addEventListener("click", disconnectWallet);
            document.getElementById("acceptCookies").addEventListener("click", acceptCookies);
            document.getElementById("closeErrorPopup").addEventListener("click", () => hidePopup("errorPopup"));
            document.getElementById("closeThanksPopup").addEventListener("click", () => hidePopup("thanksPopup"));
            document.getElementById("submitUsername").addEventListener("click", submitTwitterUsername);
            document.getElementById("closeMetamaskMobilePopup").addEventListener("click", () => hidePopup("metamaskMobilePopup"));
            document.getElementById("drawWinnerButton").addEventListener("click", debounce(handleDrawWinner, 500));
            document.getElementById("refundParticipantsButton").addEventListener("click", debounce(handleRefundParticipants, 500));
            setupImage3DEffect();
            setupMenu();
            if (!Cookies.get("acceptedCookies") && !acceptedCookies) {
                document.getElementById("cookieConsent").style.display = "block";
                document.getElementById("popupOverlay").style.display = "block";
            }
            await updateUI();
            setInterval(updateUI, 60000);
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function isMetaMaskBrowser() {
            return navigator.userAgent.includes("MetaMask");
        }

        function showMetamaskMobilePopup() {
            document.getElementById("metamaskMobilePopup").style.display = "block";
            document.getElementById("popupOverlay").style.display = "block";
        }

        async function connectWallet() {
            if (isConnecting) {
                showErrorPopup("Uma solicitação de conexão está pendente. Por favor, aguarde.");
                return;
            }
            isConnecting = true;
            console.log("Tentando conectar carteira via MetaMask...");
            try {
                if (isMobileDevice() && !isMetaMaskBrowser()) {
                    showMetamaskMobilePopup();
                    return;
                }
                if (!window.ethereum) {
                    console.log("MetaMask não detectado.");
                    showErrorPopup("MetaMask não está instalado. Instale a extensão MetaMask ou use o navegador embutido do MetaMask.");
                    return;
                }
                web3 = new Web3(window.ethereum);
                contract = new web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);
                console.log("Contrato reinicializado para MetaMask:", CONTRACT_ADDRESS);
                const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
                userAddress = accounts[0];
                console.log("Carteira conectada:", userAddress);
                const chainId = await window.ethereum.request({ method: "eth_chainId" });
                if (chainId !== MONAD_TESTNET.chainId) {
                    console.log("Trocando para Monad Testnet...");
                    try {
                        await window.ethereum.request({
                            method: "wallet_switchEthereumChain",
                            params: [{ chainId: MONAD_TESTNET.chainId }],
                        });
                    } catch (switchError) {
                        if (switchError.code === 4902) {
                            console.log("Adicionando Monad Testnet...");
                            await window.ethereum.request({
                                method: "wallet_addEthereumChain",
                                params: [{
                                    chainId: MONAD_TESTNET.chainId,
                                    chainName: MONAD_TESTNET.chainName,
                                    rpcUrls: MONAD_TESTNET.rpcUrls,
                                    nativeCurrency: MONAD_TESTNET.nativeCurrency,
                                    blockExplorerUrls: MONAD_TESTNET.blockExplorerUrls
                                }],
                            });
                        } else {
                            console.error("Erro ao trocar de rede:", switchError);
                            throw switchError;
                        }
                    }
                }
                isWalletConnected = true;
                document.getElementById("walletButton").innerText = `Wallet: ${truncateAddress(userAddress)}`;
                document.getElementById("walletMenu").classList.add("hidden");
                document.getElementById("userAddress").innerText = userAddress;
                Cookies.set("userAddress", userAddress, { expires: 7 });
                if (!xUsername) {
                    showUsernamePopup();
                } else {
                    document.getElementById("xUsernameDisplay").innerText = xUsername;
                }
                updateBuyButton();
                await updateUI();
            } catch (error) {
                console.error("Erro ao conectar MetaMask:", error);
                if (error.code === 4001 || error.message.includes("user rejected")) {
                    showErrorPopup("Você cancelou a conexão no MetaMask. Autorize a conexão para continuar.");
                } else {
                    showErrorPopup("Erro ao conectar a carteira. Tente novamente.");
                }
            } finally {
                isConnecting = false;
            }
        }

        function disconnectWallet() {
            userAddress = null;
            isWalletConnected = false;
            xUsername = "";
            Cookies.remove("userAddress");
            Cookies.remove("xUsername");
            web3 = new Web3(new Web3.providers.HttpProvider(MONAD_TESTNET.rpcUrls[0]));
            contract = new web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);
            document.getElementById("walletButton").innerText = "Conectar Carteira";
            document.getElementById("walletButton").classList.remove("disabled-button");
            document.getElementById("walletButton").classList.add("action-button");
            document.getElementById("walletMenu").classList.add("hidden");
            document.getElementById("userAddress").innerText = "";
            document.getElementById("xUsernameDisplay").innerText = "";
            const walletBalanceElement = document.getElementById("walletBalance");
            if (walletBalanceElement) walletBalanceElement.innerText = "0 MON";
            document.getElementById("drawWinnerButton").classList.add("hidden");
            document.getElementById("refundParticipantsButton").classList.add("hidden");
            updateBuyButton();
            cache = { data: null, timestamp: 0, validDuration: 60000 };
            updateUI();
        }

        function normalizeXUsername(username) {
            return username.startsWith("@") ? username : `@${username}`;
        }

        function isValidXUsername(username) {
            const cleanUsername = username.startsWith("@") ? username.slice(1) : username;
            return cleanUsername.length > 0 && /^[a-zA-Z0-9_]+$/.test(cleanUsername);
        }

        function showUsernamePopup() {
            document.getElementById("twitterUsernameInput").value = xUsername || "";
            document.getElementById("usernamePopup").style.display = "block";
            document.getElementById("popupOverlay").style.display = "block";
        }

        function submitTwitterUsername() {
            const username = document.getElementById("twitterUsernameInput").value;
            try {
                if (!username) throw new Error("Invalid username format");
                if (!isValidXUsername(username)) {
                    showErrorPopup("Insira um username válido do X (ex.: @username, apenas letras, números e sublinhados).");
                    return;
                }
                xUsername = normalizeXUsername(username);
                Cookies.set("xUsername", xUsername, { expires: 7 });
                document.getElementById("xUsernameDisplay").innerText = xUsername;
                hidePopup("usernamePopup");
            } catch (error) {
                console.error("Erro ao submeter username:", error);
                showErrorPopup(error.message || "Erro ao submeter username. Tente novamente.");
            }
        }

        function truncateAddress(address) {
            return `${address.slice(0, 6)}...${address.slice(-4)}`;
        }

        const debouncedUpdateTotalCost = debounce(function updateTotalCost() {
            console.log("Calculando total...");
            const input = document.getElementById("ticketQuantity");
            if (!input) return;
            const quantityError = document.getElementById("ticketQuantityError");
            let quantity = parseFloat(input.value);
            if (!input.value || quantity < 1 || !Number.isInteger(quantity)) {
                quantityError.classList.remove("hidden");
                quantity = 1;
                input.value = 1;
            } else {
                quantityError.classList.add("hidden");
            }
            const ticketPrice = currentTicketPrice || "200000000000000000"; // Fallback para 0.2 MON
            const total = web3.utils.toBN(quantity).mul(web3.utils.toBN(ticketPrice));
            const totalCostElement = document.getElementById("totalCost");
            if (totalCostElement) {
                totalCostElement.innerText = web3.utils.fromWei(total.toString(), "ether");
            }
        }, 100);

        async function updateWalletBalance() {
            const walletBalanceElement = document.getElementById("walletBalance");
            if (!walletBalanceElement) return;
            if (!userAddress || !isWalletConnected) {
                walletBalanceElement.innerText = "0 MON";
                return;
            }
            try {
                const balance = await web3.eth.getBalance(userAddress);
                walletBalanceElement.innerText = `${parseFloat(web3.utils.fromWei(balance, "ether")).toFixed(2)} MON`;
            } catch (error) {
                console.error("Erro ao obter saldo:", error);
                walletBalanceElement.innerText = "Erro";
            }
        }

        async function retryCall(callFn, maxRetries = 3, baseDelay = 1000) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    return await callFn();
                } catch (error) {
                    console.error(`Tentativa ${attempt} falhou: ${error.message}`);
                    if (error.message.includes("429") || error.message.includes("request limit reached")) {
                        if (attempt === maxRetries) {
                            console.error("Limite de requisições atingido.");
                            throw new Error("Limite de requisições atingido. Tente novamente mais tarde.");
                        }
                        const delay = baseDelay * Math.pow(2, attempt - 1);
                        console.warn(`Erro 429, tentando novamente após ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else if (error.message.includes("missing revert data")) {
                        console.warn("Erro de contrato (missing revert data), tentando novamente...");
                        if (attempt === maxRetries) throw error;
                        await new Promise(resolve => setTimeout(resolve, baseDelay));
                    } else {
                        throw error;
                    }
                }
            }
        }

        function updateBuyButton(isRaffleOpen = true) {
            const buyButton = document.getElementById("buyTickets");
            const raffleStatus = document.getElementById("raffleStatus");
            if (!buyButton || !raffleStatus) return;

            if (!isWalletConnected) {
                buyButton.innerText = "Conecte sua wallet primeiro";
                buyButton.disabled = true;
                buyButton.classList.remove("action-button");
                buyButton.classList.add("disabled-button");
                buyButton.onclick = null;
                raffleStatus.classList.add("hidden");
            } else if (!isRaffleOpen) {
                buyButton.innerText = "Comprar Tickets";
                buyButton.disabled = true;
                buyButton.classList.remove("action-button");
                buyButton.classList.add("disabled-button");
                buyButton.onclick = null;
                raffleStatus.classList.remove("hidden");
            } else {
                buyButton.innerText = "Comprar Tickets";
                buyButton.disabled = false;
                buyButton.classList.remove("disabled-button");
                buyButton.classList.add("action-button");
                buyButton.onclick = debounce(handleBuyTickets, 500);
                raffleStatus.classList.add("hidden");
            }
        }

        async function monitorTransaction(method, checkFn, successMessage) {
            const maxAttempts = 10;
            let attempts = 0;
            showProcessingPopup();
            while (attempts < maxAttempts) {
                try {
                    const result = await checkFn();
                    if (result.success) {
                        hidePopup("processingPopup");
                        showThanksPopup(result.message || successMessage);
                        cache = { data: null, timestamp: 0, validDuration: 60000 };
                        await updateUI();
                        return true;
                    }
                } catch (error) {
                    console.error(`Erro ao monitorar transação (${method}, tentativa ${attempts + 1}):`, error);
                }
                attempts++;
                await new Promise(resolve => setTimeout(resolve, 3000));
            }
            hidePopup("processingPopup");
            showErrorPopup("Erro ao processar a transação. Nenhuma alteração detectada após 30 segundos.");
            return false;
        }

        async function handleBuyTickets() {
            if (isProcessing) {
                showProcessingPopup();
                return;
            }
            if (!isWalletConnected) {
                showErrorPopup("Conecte sua carteira primeiro.");
                return;
            }
            isProcessing = true;
            showProcessingPopup();
            try {
    const isRaffleOpen = await retryCall(() => contract.getMethods().isRaffleOpen().call());
    if (!isRaffleOpen) {
        showErrorPopup("O sorteio está fechado.");
        return;
    }

    const alias = xUsername;
    const quantityInput = document.getElementById("ticketQuantity");
    if (!quantityInput) throw new Error("Campo de quantidade não encontrado.");

    const quantity = Math.floor(parseInt(quantityInput.value));
    if (quantity < 1 || !Number.isInteger(quantity)) {
        showErrorPopup("Quantidade de tickets inválida. Insira um número inteiro maior ou igual a 1.");
        return;
    }

    if (!alias || !isValidXUsername(alias)) {
        showErrorPopup("Username do X inválido. Insira um username válido.");
        return;
    }

    const initialTicketCount = await retryCall(() => contract.getMethods().getTicketCount(userAddress).call());
    const ticketPrice = await retryCall(() => contract.getMethods().ticketPrice().call());
    const totalValue = web3.utils.toBN(quantity).mul(web3.utils.toBN(ticketPrice)).toString();

    console.log("Enviando transação de compra...", { userAddress, quantity, totalValue, alias });

    try {
        const tx = await contract.getMethods().buyTickets(quantity, alias).send({ from: userAddress, value: totalValue });

        const checkFn = async () => {
            const currentTicketCount = await retryCall(() => contract.getMethods().getTicketCount(userAddress).call());

            return {
                success: parseInt(currentTicketCount) > parseInt(initialTicketCount),
                message: message("Obrigado por ajudar a comunidade Monad. Boa Sorte!")
            };
        };

        await monitorTransaction("buyTickets", checkFn, "Obrigado por ajudar a comunidade Monad. Boa sorte na rifa!");

    } catch (error) {
        if (error.code === 4001 || error.message.includes("user rejected")) {
            hidePopup("processingPopup");
            showErrorPopup("Transação rejeitada no MetaMask. Autorize a transação para continuar.");
            return;
        }

        console.error("Erro crítico ao comprar tickets:", error);
        showErrorPopup("Erro ao iniciar a compra de tickets. Tente novamente.");

    } finally {
        isProcessing = false;
        hidePopup("processingPopup");
    }

} catch (error) {
    console.error("Erro geral no fluxo de compra:", error);
    showErrorPopup("Erro inesperado. Verifique os dados e tente novamente.");
}


            async function handleDrawWinner() {
                if (isProcessing) {
                    showProcessingPopup();
                    return;
                }
                if (!isWalletConnected) {
                    showErrorPopup("Conecte sua carteira principal primeiro.");
                    return;
                }
                isProcessing = true;
                showProcessingPopup();
                try {
                    const owner = await retryCall(() => contract.getMethods().owner().call());
                    if (userAddress.toLowerCase() !== owner.toLowerCase()) {
                        showErrorPopup("Apenas o dono do contrato pode sortear o ganhador.");
                        return;
                    }
                    const initialPastWinners = await retryCall(() => contract.getMethods().getPastWinners().call());
                    console.log("Enviando transação para sortear ganhador...");
                    try {
                        const tx = await contract.getMethods().drawWinner().send({ from: userAddress });
                        const checkFn = async () => {
                            const currentPastWinners = await retryCall(() => contract.getMethods().getPastWinners().call());
                            if (currentPastWinners.length > initialPastWinners.length) {
                                const winner = currentPastWinners[currentPastWinners.length - 1];
                                const winnerTwitter = await retryCall(() => contract.getMethods().getAlias(winner).call());
                                return {
                                    success: true,
                                    message: `Sorteio realizado com sucesso! Ganhador: ${truncateAddress(winner)} (${winnerTwitter || 'N/A'})`
                                };
                            }
                            return { success: false };
                        };
                        await monitorTransaction("drawWinner", checkFn, "Sorteio realizado com sucesso!");
                    } catch (error) {
                        if (error.code === 4001 || error.message.includes("user rejected")) {
                            hidePopup("processingPopup");
                            showErrorPopup("Transação rejeitada no MetaMask. Autorize a transação para continuar.");
                            return;
                        }
                        throw error;
                    }
                } catch (error) {
                    console.error("Erro crítico ao sortear ganhador:", error);
                    showErrorPopup("Erro ao iniciar o sorteio. Tente novamente.");
                } finally {
                    isProcessing = false;
                    hidePopup("processingPopup");
                }
            }

            async function handleRefundParticipants() {
                if (isProcessing) {
                    showProcessingPopup();
                    return;
                }
                if (!isWalletConnected) {
                    showErrorPopup("Conecte sua carteira principal primeiro.");
                    return;
                }
                isProcessing = true;
                showProcessingPopup();
                try {
                    const owner = await retryCall(() => contract.getMethods().owner().call());
                    if (userAddress.toLowerCase() !== owner.toLowerCase()) {
                        showErrorPopup("Apenas o dono do contrato pode realizar reembolsos.");
                        return;
                    }
                    const initialBalance = await retryCall(() => contract.getMethods().getContractBalance().call());
                    console.log("Executando reembolso...");
                    try {
                        const tx = await contract.getMethods().refundParticipants().send({ from: userAddress });
                        const checkFn = async () => {
                            const currentBalance = await retryCall(() => contract.getMethods().getContractBalance().call());
                            return {
                                success: web3.utils.toBN(currentBalance).isZero(),
                                message: "Reembolsos realizados com sucesso!"
                            };
                        };
                        await monitorTransaction("refundParticipants", checkFn, "Reembolsos realizados com sucesso!");
                    } catch (error) {
                        if (error.code === 4001 || error.message.includes("user rejected")) {
                            hidePopup("processingPopup");
                            showErrorPopup("Transação rejeitada no MetaMask. Autorize a transação para continuar.");
                            return;
                        }
                        throw error;
                    }
                } catch (error) {
                    console.error("Erro crítico ao reembolsar participantes:", error);
                    showErrorPopup("Erro ao realizar reembolsos. Tente novamente.");
                } finally {
                    isProcessing = false;
                    hidePopup("processingPopup");
                }
            }

            function setupMenu() {
                let isMouseOverButton = false;
                let isMouseOverMenu = false;
                const walletButton = document.getElementById("walletButton");
                const walletMenu = document.getElementById("walletMenu");
                if (!walletButton || !walletMenu) return;
                walletButton.addEventListener("mouseenter", () => {
                    isMouseOverButton = true;
                    if (isWalletConnected) {
                        walletMenu.classList.remove("hidden");
                        console.log("Menu aberto (mouseenter no botão)");
                    }
                });
                walletButton.addEventListener("mouseleave", () => {
                    isMouseOverButton = false;
                    console.log("Mouse saiu do botão");
                });
                walletMenu.addEventListener("mouseenter", () => {
                    isMouseOverMenu = true;
                    console.log("Mouse sobre o menu");
                });
                walletMenu.addEventListener("mouseleave", () => {
                    isMouseOverMenu = false;
                    console.log("Mouse saiu do menu");
                });
                document.addEventListener("click", (e) => {
                    if (!isMouseOverButton && !isMouseOverMenu && !walletButton.contains(e.target) && !walletMenu.contains(e.target)) {
                        walletMenu.classList.add("hidden");
                        console.log("Menu fechado (click fora)");
                    }
                });
            }

            function showErrorPopup(message) {
                console.log("Exibindo erro:", message);
                const errorMessage = document.getElementById("errorMessage");
                const errorPopup = document.getElementById("errorPopup");
                const popupOverlay = document.getElementById("popupOverlay");
                if (errorMessage && errorPopup && popupOverlay) {
                    errorMessage.innerText = message;
                    errorPopup.style.display = "block";
                    popupOverlay.style.display = "block";
                }
            }

            function showProcessingPopup() {
                const processingPopup = document.getElementById("processingPopup");
                const popupOverlay = document.getElementById("popupOverlay");
                if (processingPopup && popupOverlay) {
                    processingPopup.style.display = "block";
                    popupOverlay.style.display = "block";
                }
            }

            function showThanksPopup(message) {
                const thanksMessage = document.getElementById("thanksMessage");
                const thanksPopup = document.getElementById("thanksPopup");
                const popupOverlay = document.getElementById("popupOverlay");
                if (thanksMessage && thanksPopup && popupOverlay) {
                    thanksMessage.innerText = message;
                    thanksPopup.style.display = "block";
                    popupOverlay.style.display = "block";
                }
            }

            function hidePopup(popupId) {
                const popup = document.getElementById(popupId);
                if (popup) popup.style.display = "none";
                const popups = [
                    "errorPopup",
                    "processingPopup",
                    "thanksPopup",
                    "usernamePopup",
                    "metamaskMobilePopup",
                    "cookieConsent"
                ];
                const popupOverlay = document.getElementById("popupOverlay");
                if (popupOverlay && !popups.some(p => document.getElementById(p)?.style.display === "block")) {
                    popupOverlay.style.display = "none";
                }
            }

            function acceptCookies() {
                acceptedCookies = true;
                Cookies.set("acceptedCookies", "true", { expires: 365 });
                hidePopup("cookieConsent");
            }

            function setupImage3DEffect() {
                const image = document.getElementById("sorteioImage");
                if (!image) return;
                const imageRect = image.getBoundingClientRect();
                image.addEventListener("mousemove", (event) => {
                    const x = event.clientX - imageRect.left;
                    const y = event.clientY - imageRect.top;
                    const centerX = imageRect.width / 2;
                    const centerY = imageRect.height / 2;
                    const maxTilt = 20;
                    const tiltX = ((centerY - y) / centerY) * maxTilt;
                    const tiltY = ((x - centerX) / centerX) * maxTilt;
                    image.style.transform = `perspective(1000px) rotateX(${tiltX}deg) rotateY(${tiltY}deg)`;
                });
                image.addEventListener("mouseleave", () => {
                    image.style.transform = "perspective(1000px) rotateX(0deg) rotateY(0deg)";
                });
            }

            async function updateUI() {
                try {
                    let ticketPrice = "0", ticketCount = "0", participants = [], isRaffleOpen = false, lastWinner = null, lastWinnerTwitter = null, owner = null;
                    let currentQuantity = 1;
                    const ticketQuantityInput = document.getElementById("ticketQuantity");
                    if (ticketQuantityInput && ticketQuantityInput.value) {
                        currentQuantity = parseInt(ticketQuantityInput.value) || 1;
                    }
                    if (cache.data && Date.now() - cache.timestamp < cache.validDuration) {
                        ({ ticketPrice, ticketCount, participants, isRaffleOpen, lastWinner, lastWinnerTwitter, owner } = cache.data);
                    } else {
                        try {
                            console.log("Lendo ticketPrice...");
                            ticketPrice = await retryCall(() => contract.getMethods().ticketPrice().call());
                            currentTicketPrice = ticketPrice;
                        } catch (error) {
                            console.error("Erro ao ler ticketPrice: ", error);
                            }
                        } catch {
                            console.log("Lendo participantes...");
                            try {
                            participants = await retryCall(() => contract.getMethods().getParticipants().call());
                        } catch (error) {
                            console.error("Erro ao ler participantes:", error);
                        }
                        try {
                            console.log("Lendo status do sorteio...");
                            isRaffleOpen = await retryCall(() => contract.getMethods().isRaffleOpen().call());
                        } catch (error) {
                            console.error("Erro ao ler isRaffleOpen:", error);
                        }
                        try {
                            console.log("Lendo último ganhador...");
                            const pastWinners = await retryCall(() => contract.getMethods().getPastWinners().call());
                            if (pastWinners && pastWinners.length > 0) {
                                lastWinner = pastWinners[pastWinners.length - 1];
                                lastWinnerTwitter = await retryCall(() => contract.getMethods().getAlias(lastWinner).call());
                            }
                        } catch (error) {
                            console.error("Erro ao ler pastWinners ou getAlias:", error);
                        }
                        try {
                            console.log("Lendo owner...");
                            owner = await retryCall(() => contract.getMethods().owner().call());
                        } catch (error) {
                            console.error("Erro ao ler owner:", error);
                        }
                        if (isWalletConnected && userAddress) {
                            try {
                                console.log("Lendo ticketCount para:", userAddress);
                                ticketCount = await retryCall(() => contract.getMethods().getTicketCount(userAddress).call());
                            } catch (error) {
                                console.error("Erro ao ler ticketCount:", error);
                            }
                        }
                        cache.data = { ticketPrice, ticketCount, participants, isRaffleOpen, lastWinner, lastWinnerTwitter, owner };
                        cache.timestamp = Date.now();
                    }
                    const drawWinnerButton = document.getElementById("drawWinnerButton");
                    const refundParticipantsButton = document.getElementById("refundParticipantsButton");
                    if (isWalletConnected && userAddress && owner && userAddress.toLowerCase() === owner.toLowerCase()) {
                        if (drawWinnerButton) drawWinnerButton.classList.remove("hidden");
                        if (refundParticipantsButton) refundParticipantsButton.classList.remove("hidden");
                    } else {
                        if (drawWinnerButton) drawWinnerButton.classList.add("hidden");
                        if (refundParticipantsButton) refundParticipantsButton.classList.add("hidden");
                    }
                    const ticketSection = document.getElementById("ticketSection");
                    if (!ticketSection) return;
                    const isCurrentlyBuyForm = ticketSection.querySelector("#buyTicketsForm") !== null;
                    if (!isRaffleOpen && lastWinner) {
                        ticketSection.innerHTML = `
                            <p class="text-base"><strong>Último Ganhador:</strong> ${truncateAddress(lastWinner)} (Twitter: ${lastWinnerTwitter || 'N/A'})</p>
                        `;
                    } else if (!isRaffleOpen) {
                        ticketSection.innerHTML = `
                            <p class="text-base"><strong>Nenhum ganhador ainda.</strong></p>
                        `;
                    } else if (!isCurrentlyBuyForm) {
                        ticketSection.innerHTML = BUY_TICKETS_FORM;
                        const newQuantityInput = document.getElementById("ticketQuantity");
                        if (newQuantityInput) {
                            newQuantityInput.value = currentQuantity;
                            newQuantityInput.addEventListener("input", debouncedUpdateTotalCost);
                        }
                        const ticketPriceElement = document.getElementById("ticketPrice");
                        const participantCountElement = document.getElementById("participantCount");
                        const ticketCountElement = document.getElementById("ticketCount");
                        if (ticketPriceElement) {
                            ticketPriceElement.innerText = ticketPrice === "0" ? "0.2" : web3.utils.fromWei(totalPrice, "ether");
                        }
                        if (participantCountElement) {
                            participantCountElement.innerText = participants.length;
                        }
                        if (ticketCountElement) {
                            ticketCountElement.innerText = isWalletConnected ? ticketCount : "Conecte sua Wallet";
                        }
                        const buyTicketsButton = document.getElementById("buyTickets");
                        if (buyTicketsButton) {
                            buyTicketsButton.addEventListener("click", debounce(handleBuyTickets, 500));
                        }
                    } else {
                        const ticketPriceElement = document.getElementById("ticketPrice");
                        const participantCountElement = document.getElementById("participantCount");
                        const ticketCountElement = document.getElementById("ticketCount");
                        if (ticketPriceElement) {
                            ticketPriceElement.innerText = ticketPrice === "0" ? "0.2" : web3.utils.fromWei(totalPrice, "ether");
                        }
                        if (participantCountElement) {
                            participantCountElement.innerText = participants.length;
                        }
                        if (ticketCountElement) {
                            ticketCountElement.innerText = isWalletConnected ? ticketCount : "Conecte sua Wallet";
                        }
                    }
                    if (isWalletConnected) {
                        await updateWalletBalance();
                        debouncedUpdateTotalCost();
                        updateBuyButton(isRaffleOpen);
                    } else {
                        const walletBalanceElement = document.getElementById("walletBalance");
                        const totalCostElement = document.getElementById("totalCost");
                        if (walletBalanceElement) walletBalanceElement.innerText = "0 MON";
                        if (totalCostElement) totalCostElement.innerText = ticketPrice === "0" ? "0.2" : web3.utils.fromWei(totalPrice.toString(), "ether");
                        updateBuyButton(isRaffleOpen);
                    }
                    const participantsList = document.getElementById("participantsList");
                    const participantsSection = document.getElementById("participantsSection");
                    if (!participantsList || !participantsSection) return;
                    participantsList.innerHTML = "";
                    const participantData = [];
                    const uniqueParticipants = [...new Set(participants)];
                    for (let i = 0; i < Math.min(uniqueParticipants.length, 5); i++) {
                        const participant = uniqueParticipants[i];
                        if (!web3.utils.isAddress(participant)) continue;
                        let alias = "Desconhecido";
                        let count = 0;
                        try {
                            alias = await retryCall(() => contract.getMethods().getAlias(participant).call());
                            count = await retryCall(() => contract.getMethods().getTicketCount(participant).call());
                        } catch (error) {
                            console.error(`Erro ao obter dados do participante ${participant}:`, error);
                        }
                        participantData.push({ address: participant, alias, count });
                    }
                    participantData.sort((a, b) => b.count - a.count);
                    participantData.forEach(({ address, alias, count }, index) => {
                        const li = document.createElement("li");
                        li.setAttribute("data-rank", index + 1);
                        li.innerText = `${truncateAddress(address)} (${alias}): ${count} tickets`;
                        participantsList.appendChild(li);
                    });
                    if (participantsSection) {
                        participantsSection.style.display = participantData.length > 0 ? "block" : "none";
                    }
                } catch (error) {
                    console.error("Erro ao atualizar UI:", error);
                    showErrorPopup("Erro ao atualizar a interface. Tente novamente.");
                }
            }

            window.onload = init;
        }
    </script>
</body>
</html>
